// Generated by gencpp from file msg_gen/mainvehicle.msg
// DO NOT EDIT!


#ifndef MSG_GEN_MESSAGE_MAINVEHICLE_H
#define MSG_GEN_MESSAGE_MAINVEHICLE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace msg_gen
{
template <class ContainerAllocator>
struct mainvehicle_
{
  typedef mainvehicle_<ContainerAllocator> Type;

  mainvehicle_()
    : mainVehicleId(0)
    , posX(0.0)
    , posY(0.0)
    , posZ(0.0)
    , oriX(0.0)
    , oriY(0.0)
    , oriZ(0.0)
    , speed(0.0)
    , nextTrafficLightColorId(0)
    , gear(0)
    , throttle(0.0)
    , brake(0.0)
    , steering(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)  {
    }
  mainvehicle_(const ContainerAllocator& _alloc)
    : mainVehicleId(0)
    , posX(0.0)
    , posY(0.0)
    , posZ(0.0)
    , oriX(0.0)
    , oriY(0.0)
    , oriZ(0.0)
    , speed(0.0)
    , nextTrafficLightColorId(0)
    , gear(0)
    , throttle(0.0)
    , brake(0.0)
    , steering(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _mainVehicleId_type;
  _mainVehicleId_type mainVehicleId;

   typedef double _posX_type;
  _posX_type posX;

   typedef double _posY_type;
  _posY_type posY;

   typedef double _posZ_type;
  _posZ_type posZ;

   typedef double _oriX_type;
  _oriX_type oriX;

   typedef double _oriY_type;
  _oriY_type oriY;

   typedef double _oriZ_type;
  _oriZ_type oriZ;

   typedef double _speed_type;
  _speed_type speed;

   typedef int32_t _nextTrafficLightColorId_type;
  _nextTrafficLightColorId_type nextTrafficLightColorId;

   typedef int32_t _gear_type;
  _gear_type gear;

   typedef double _throttle_type;
  _throttle_type throttle;

   typedef double _brake_type;
  _brake_type brake;

   typedef double _steering_type;
  _steering_type steering;

   typedef double _length_type;
  _length_type length;

   typedef double _width_type;
  _width_type width;

   typedef double _height_type;
  _height_type height;





  typedef boost::shared_ptr< ::msg_gen::mainvehicle_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::msg_gen::mainvehicle_<ContainerAllocator> const> ConstPtr;

}; // struct mainvehicle_

typedef ::msg_gen::mainvehicle_<std::allocator<void> > mainvehicle;

typedef boost::shared_ptr< ::msg_gen::mainvehicle > mainvehiclePtr;
typedef boost::shared_ptr< ::msg_gen::mainvehicle const> mainvehicleConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::msg_gen::mainvehicle_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::msg_gen::mainvehicle_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::msg_gen::mainvehicle_<ContainerAllocator1> & lhs, const ::msg_gen::mainvehicle_<ContainerAllocator2> & rhs)
{
  return lhs.mainVehicleId == rhs.mainVehicleId &&
    lhs.posX == rhs.posX &&
    lhs.posY == rhs.posY &&
    lhs.posZ == rhs.posZ &&
    lhs.oriX == rhs.oriX &&
    lhs.oriY == rhs.oriY &&
    lhs.oriZ == rhs.oriZ &&
    lhs.speed == rhs.speed &&
    lhs.nextTrafficLightColorId == rhs.nextTrafficLightColorId &&
    lhs.gear == rhs.gear &&
    lhs.throttle == rhs.throttle &&
    lhs.brake == rhs.brake &&
    lhs.steering == rhs.steering &&
    lhs.length == rhs.length &&
    lhs.width == rhs.width &&
    lhs.height == rhs.height;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::msg_gen::mainvehicle_<ContainerAllocator1> & lhs, const ::msg_gen::mainvehicle_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace msg_gen

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::msg_gen::mainvehicle_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::msg_gen::mainvehicle_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_gen::mainvehicle_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_gen::mainvehicle_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_gen::mainvehicle_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_gen::mainvehicle_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::msg_gen::mainvehicle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "abe1bc3b5679218b744ccfb91e405f05";
  }

  static const char* value(const ::msg_gen::mainvehicle_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xabe1bc3b5679218bULL;
  static const uint64_t static_value2 = 0x744ccfb91e405f05ULL;
};

template<class ContainerAllocator>
struct DataType< ::msg_gen::mainvehicle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "msg_gen/mainvehicle";
  }

  static const char* value(const ::msg_gen::mainvehicle_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::msg_gen::mainvehicle_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 mainVehicleId\n"
"float64 posX\n"
"float64 posY\n"
"float64 posZ\n"
"float64 oriX\n"
"float64 oriY\n"
"float64 oriZ\n"
"float64 speed\n"
"int32 nextTrafficLightColorId\n"
"int32 gear\n"
"float64 throttle\n"
"float64 brake\n"
"float64 steering\n"
"float64 length\n"
"float64 width\n"
"float64 height\n"
;
  }

  static const char* value(const ::msg_gen::mainvehicle_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::msg_gen::mainvehicle_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.mainVehicleId);
      stream.next(m.posX);
      stream.next(m.posY);
      stream.next(m.posZ);
      stream.next(m.oriX);
      stream.next(m.oriY);
      stream.next(m.oriZ);
      stream.next(m.speed);
      stream.next(m.nextTrafficLightColorId);
      stream.next(m.gear);
      stream.next(m.throttle);
      stream.next(m.brake);
      stream.next(m.steering);
      stream.next(m.length);
      stream.next(m.width);
      stream.next(m.height);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mainvehicle_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::msg_gen::mainvehicle_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::msg_gen::mainvehicle_<ContainerAllocator>& v)
  {
    s << indent << "mainVehicleId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.mainVehicleId);
    s << indent << "posX: ";
    Printer<double>::stream(s, indent + "  ", v.posX);
    s << indent << "posY: ";
    Printer<double>::stream(s, indent + "  ", v.posY);
    s << indent << "posZ: ";
    Printer<double>::stream(s, indent + "  ", v.posZ);
    s << indent << "oriX: ";
    Printer<double>::stream(s, indent + "  ", v.oriX);
    s << indent << "oriY: ";
    Printer<double>::stream(s, indent + "  ", v.oriY);
    s << indent << "oriZ: ";
    Printer<double>::stream(s, indent + "  ", v.oriZ);
    s << indent << "speed: ";
    Printer<double>::stream(s, indent + "  ", v.speed);
    s << indent << "nextTrafficLightColorId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.nextTrafficLightColorId);
    s << indent << "gear: ";
    Printer<int32_t>::stream(s, indent + "  ", v.gear);
    s << indent << "throttle: ";
    Printer<double>::stream(s, indent + "  ", v.throttle);
    s << indent << "brake: ";
    Printer<double>::stream(s, indent + "  ", v.brake);
    s << indent << "steering: ";
    Printer<double>::stream(s, indent + "  ", v.steering);
    s << indent << "length: ";
    Printer<double>::stream(s, indent + "  ", v.length);
    s << indent << "width: ";
    Printer<double>::stream(s, indent + "  ", v.width);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MSG_GEN_MESSAGE_MAINVEHICLE_H
