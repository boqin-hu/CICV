// Generated by gencpp from file msg_gen/SimOne_Data_SensorDetections_Entry.msg
// DO NOT EDIT!


#ifndef MSG_GEN_MESSAGE_SIMONE_DATA_SENSORDETECTIONS_ENTRY_H
#define MSG_GEN_MESSAGE_SIMONE_DATA_SENSORDETECTIONS_ENTRY_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <msg_gen/SimOne_Obstacle_Type.h>

namespace msg_gen
{
template <class ContainerAllocator>
struct SimOne_Data_SensorDetections_Entry_
{
  typedef SimOne_Data_SensorDetections_Entry_<ContainerAllocator> Type;

  SimOne_Data_SensorDetections_Entry_()
    : id(0)
    , type()
    , posX(0.0)
    , posY(0.0)
    , posZ(0.0)
    , oriX(0.0)
    , oriY(0.0)
    , oriZ(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , range(0.0)
    , velX(0.0)
    , velY(0.0)
    , velZ(0.0)
    , probability(0.0)
    , relativePosX(0.0)
    , relativePosY(0.0)
    , relativePosZ(0.0)
    , relativeRotX(0.0)
    , relativeRotY(0.0)
    , relativeRotZ(0.0)
    , relativeVelX(0.0)
    , relativeVelY(0.0)
    , relativeVelZ(0.0)
    , bbox2dMinX(0.0)
    , bbox2dMinY(0.0)
    , bbox2dMaxX(0.0)
    , bbox2dMaxY(0.0)  {
    }
  SimOne_Data_SensorDetections_Entry_(const ContainerAllocator& _alloc)
    : id(0)
    , type(_alloc)
    , posX(0.0)
    , posY(0.0)
    , posZ(0.0)
    , oriX(0.0)
    , oriY(0.0)
    , oriZ(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , range(0.0)
    , velX(0.0)
    , velY(0.0)
    , velZ(0.0)
    , probability(0.0)
    , relativePosX(0.0)
    , relativePosY(0.0)
    , relativePosZ(0.0)
    , relativeRotX(0.0)
    , relativeRotY(0.0)
    , relativeRotZ(0.0)
    , relativeVelX(0.0)
    , relativeVelY(0.0)
    , relativeVelZ(0.0)
    , bbox2dMinX(0.0)
    , bbox2dMinY(0.0)
    , bbox2dMaxX(0.0)
    , bbox2dMaxY(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _id_type;
  _id_type id;

   typedef  ::msg_gen::SimOne_Obstacle_Type_<ContainerAllocator>  _type_type;
  _type_type type;

   typedef double _posX_type;
  _posX_type posX;

   typedef double _posY_type;
  _posY_type posY;

   typedef double _posZ_type;
  _posZ_type posZ;

   typedef double _oriX_type;
  _oriX_type oriX;

   typedef double _oriY_type;
  _oriY_type oriY;

   typedef double _oriZ_type;
  _oriZ_type oriZ;

   typedef double _length_type;
  _length_type length;

   typedef double _width_type;
  _width_type width;

   typedef double _height_type;
  _height_type height;

   typedef double _range_type;
  _range_type range;

   typedef double _velX_type;
  _velX_type velX;

   typedef double _velY_type;
  _velY_type velY;

   typedef double _velZ_type;
  _velZ_type velZ;

   typedef double _probability_type;
  _probability_type probability;

   typedef double _relativePosX_type;
  _relativePosX_type relativePosX;

   typedef double _relativePosY_type;
  _relativePosY_type relativePosY;

   typedef double _relativePosZ_type;
  _relativePosZ_type relativePosZ;

   typedef double _relativeRotX_type;
  _relativeRotX_type relativeRotX;

   typedef double _relativeRotY_type;
  _relativeRotY_type relativeRotY;

   typedef double _relativeRotZ_type;
  _relativeRotZ_type relativeRotZ;

   typedef double _relativeVelX_type;
  _relativeVelX_type relativeVelX;

   typedef double _relativeVelY_type;
  _relativeVelY_type relativeVelY;

   typedef double _relativeVelZ_type;
  _relativeVelZ_type relativeVelZ;

   typedef double _bbox2dMinX_type;
  _bbox2dMinX_type bbox2dMinX;

   typedef double _bbox2dMinY_type;
  _bbox2dMinY_type bbox2dMinY;

   typedef double _bbox2dMaxX_type;
  _bbox2dMaxX_type bbox2dMaxX;

   typedef double _bbox2dMaxY_type;
  _bbox2dMaxY_type bbox2dMaxY;





  typedef boost::shared_ptr< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> const> ConstPtr;

}; // struct SimOne_Data_SensorDetections_Entry_

typedef ::msg_gen::SimOne_Data_SensorDetections_Entry_<std::allocator<void> > SimOne_Data_SensorDetections_Entry;

typedef boost::shared_ptr< ::msg_gen::SimOne_Data_SensorDetections_Entry > SimOne_Data_SensorDetections_EntryPtr;
typedef boost::shared_ptr< ::msg_gen::SimOne_Data_SensorDetections_Entry const> SimOne_Data_SensorDetections_EntryConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator1> & lhs, const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.type == rhs.type &&
    lhs.posX == rhs.posX &&
    lhs.posY == rhs.posY &&
    lhs.posZ == rhs.posZ &&
    lhs.oriX == rhs.oriX &&
    lhs.oriY == rhs.oriY &&
    lhs.oriZ == rhs.oriZ &&
    lhs.length == rhs.length &&
    lhs.width == rhs.width &&
    lhs.height == rhs.height &&
    lhs.range == rhs.range &&
    lhs.velX == rhs.velX &&
    lhs.velY == rhs.velY &&
    lhs.velZ == rhs.velZ &&
    lhs.probability == rhs.probability &&
    lhs.relativePosX == rhs.relativePosX &&
    lhs.relativePosY == rhs.relativePosY &&
    lhs.relativePosZ == rhs.relativePosZ &&
    lhs.relativeRotX == rhs.relativeRotX &&
    lhs.relativeRotY == rhs.relativeRotY &&
    lhs.relativeRotZ == rhs.relativeRotZ &&
    lhs.relativeVelX == rhs.relativeVelX &&
    lhs.relativeVelY == rhs.relativeVelY &&
    lhs.relativeVelZ == rhs.relativeVelZ &&
    lhs.bbox2dMinX == rhs.bbox2dMinX &&
    lhs.bbox2dMinY == rhs.bbox2dMinY &&
    lhs.bbox2dMaxX == rhs.bbox2dMaxX &&
    lhs.bbox2dMaxY == rhs.bbox2dMaxY;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator1> & lhs, const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace msg_gen

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8f343f0647b7cc9bd8409925779ecbbf";
  }

  static const char* value(const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8f343f0647b7cc9bULL;
  static const uint64_t static_value2 = 0xd8409925779ecbbfULL;
};

template<class ContainerAllocator>
struct DataType< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
{
  static const char* value()
  {
    return "msg_gen/SimOne_Data_SensorDetections_Entry";
  }

  static const char* value(const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 id\n"
"SimOne_Obstacle_Type type\n"
"float64 posX\n"
"float64 posY\n"
"float64 posZ\n"
"float64 oriX\n"
"float64 oriY\n"
"float64 oriZ\n"
"float64 length\n"
"float64 width\n"
"float64 height\n"
"float64 range\n"
"float64 velX\n"
"float64 velY\n"
"float64 velZ\n"
"float64 probability\n"
"float64 relativePosX\n"
"float64 relativePosY\n"
"float64 relativePosZ\n"
"float64 relativeRotX\n"
"float64 relativeRotY\n"
"float64 relativeRotZ\n"
"float64 relativeVelX\n"
"float64 relativeVelY\n"
"float64 relativeVelZ\n"
"float64 bbox2dMinX\n"
"float64 bbox2dMinY\n"
"float64 bbox2dMaxX\n"
"float64 bbox2dMaxY\n"
"================================================================================\n"
"MSG: msg_gen/SimOne_Obstacle_Type\n"
"uint8 ESimOne_Obstacle_Type_Unknown = 0\n"
"uint8 ESimOne_Obstacle_Type_Pedestrian = 4\n"
"uint8 ESimOne_Obstacle_Type_Pole = 5\n"
"uint8 ESimOne_Obstacle_Type_Car = 6\n"
"uint8 ESimOne_Obstacle_Type_Static = 7\n"
"uint8 ESimOne_Obstacle_Type_Bicycle = 8\n"
"uint8 ESimOne_Obstacle_Type_Fence = 9\n"
"uint8 ESimOne_Obstacle_Type_RoadMark = 12\n"
"uint8 ESimOne_Obstacle_Type_TrafficSign = 13\n"
"uint8 ESimOne_Obstacle_Type_TrafficLight = 15\n"
"uint8 ESimOne_Obstacle_Type_Rider = 17\n"
"uint8 ESimOne_Obstacle_Type_Truck = 18\n"
"uint8 ESimOne_Obstacle_Type_Bus = 19\n"
"uint8 ESimOne_Obstacle_Type_SpecialVehicle = 20\n"
"uint8 ESimOne_Obstacle_Type_Motorcycle = 21\n"
"uint8 ESimOne_Obstacle_Type_Dynamic = 22\n"
"uint8 ESimOne_Obstacle_Type_GuardRail = 23\n"
"uint8 ESimOne_Obstacle_Type_SpeedLimitSign = 26\n"
"uint8 ESimOne_Obstacle_Type_BicycleStatic = 27\n"
"uint8 ESimOne_Obstacle_Type_RoadObstacle = 29\n"
"uint32 SimOne_Obstacle_Type\n"
;
  }

  static const char* value(const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.type);
      stream.next(m.posX);
      stream.next(m.posY);
      stream.next(m.posZ);
      stream.next(m.oriX);
      stream.next(m.oriY);
      stream.next(m.oriZ);
      stream.next(m.length);
      stream.next(m.width);
      stream.next(m.height);
      stream.next(m.range);
      stream.next(m.velX);
      stream.next(m.velY);
      stream.next(m.velZ);
      stream.next(m.probability);
      stream.next(m.relativePosX);
      stream.next(m.relativePosY);
      stream.next(m.relativePosZ);
      stream.next(m.relativeRotX);
      stream.next(m.relativeRotY);
      stream.next(m.relativeRotZ);
      stream.next(m.relativeVelX);
      stream.next(m.relativeVelY);
      stream.next(m.relativeVelZ);
      stream.next(m.bbox2dMinX);
      stream.next(m.bbox2dMinY);
      stream.next(m.bbox2dMaxX);
      stream.next(m.bbox2dMaxY);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SimOne_Data_SensorDetections_Entry_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::msg_gen::SimOne_Data_SensorDetections_Entry_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id);
    s << indent << "type: ";
    s << std::endl;
    Printer< ::msg_gen::SimOne_Obstacle_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.type);
    s << indent << "posX: ";
    Printer<double>::stream(s, indent + "  ", v.posX);
    s << indent << "posY: ";
    Printer<double>::stream(s, indent + "  ", v.posY);
    s << indent << "posZ: ";
    Printer<double>::stream(s, indent + "  ", v.posZ);
    s << indent << "oriX: ";
    Printer<double>::stream(s, indent + "  ", v.oriX);
    s << indent << "oriY: ";
    Printer<double>::stream(s, indent + "  ", v.oriY);
    s << indent << "oriZ: ";
    Printer<double>::stream(s, indent + "  ", v.oriZ);
    s << indent << "length: ";
    Printer<double>::stream(s, indent + "  ", v.length);
    s << indent << "width: ";
    Printer<double>::stream(s, indent + "  ", v.width);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
    s << indent << "range: ";
    Printer<double>::stream(s, indent + "  ", v.range);
    s << indent << "velX: ";
    Printer<double>::stream(s, indent + "  ", v.velX);
    s << indent << "velY: ";
    Printer<double>::stream(s, indent + "  ", v.velY);
    s << indent << "velZ: ";
    Printer<double>::stream(s, indent + "  ", v.velZ);
    s << indent << "probability: ";
    Printer<double>::stream(s, indent + "  ", v.probability);
    s << indent << "relativePosX: ";
    Printer<double>::stream(s, indent + "  ", v.relativePosX);
    s << indent << "relativePosY: ";
    Printer<double>::stream(s, indent + "  ", v.relativePosY);
    s << indent << "relativePosZ: ";
    Printer<double>::stream(s, indent + "  ", v.relativePosZ);
    s << indent << "relativeRotX: ";
    Printer<double>::stream(s, indent + "  ", v.relativeRotX);
    s << indent << "relativeRotY: ";
    Printer<double>::stream(s, indent + "  ", v.relativeRotY);
    s << indent << "relativeRotZ: ";
    Printer<double>::stream(s, indent + "  ", v.relativeRotZ);
    s << indent << "relativeVelX: ";
    Printer<double>::stream(s, indent + "  ", v.relativeVelX);
    s << indent << "relativeVelY: ";
    Printer<double>::stream(s, indent + "  ", v.relativeVelY);
    s << indent << "relativeVelZ: ";
    Printer<double>::stream(s, indent + "  ", v.relativeVelZ);
    s << indent << "bbox2dMinX: ";
    Printer<double>::stream(s, indent + "  ", v.bbox2dMinX);
    s << indent << "bbox2dMinY: ";
    Printer<double>::stream(s, indent + "  ", v.bbox2dMinY);
    s << indent << "bbox2dMaxX: ";
    Printer<double>::stream(s, indent + "  ", v.bbox2dMaxX);
    s << indent << "bbox2dMaxY: ";
    Printer<double>::stream(s, indent + "  ", v.bbox2dMaxY);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MSG_GEN_MESSAGE_SIMONE_DATA_SENSORDETECTIONS_ENTRY_H
