// Generated by gencpp from file control_msgs/control_sys.msg
// DO NOT EDIT!


#ifndef CONTROL_MSGS_MESSAGE_CONTROL_SYS_H
#define CONTROL_MSGS_MESSAGE_CONTROL_SYS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace control_msgs
{
template <class ContainerAllocator>
struct control_sys_
{
  typedef control_sys_<ContainerAllocator> Type;

  control_sys_()
    : lat_targetangle(0.0)
    , lat_targettorque(0.0)
    , vehicle_shiftposition(0)
    , vehicle_sys_status(0)
    , actuatormode(0)
    , shiftposition(0)
    , brakelight(0)
    , reverselight(0)
    , epb_status(0)
    , vehicle_auto_enable(false)
    , vehicle_lat_enable(false)
    , vehicle_lon_enable(false)
    , vehicle_epb_status(false)
    , road_vaild_flag(false)
    , calibration_flag(false)
    , write_enable_flag(false)
    , PowerFault(0)
    , ComFault(0)
    , USSFault(0)
    , ChassisFault(0)  {
    }
  control_sys_(const ContainerAllocator& _alloc)
    : lat_targetangle(0.0)
    , lat_targettorque(0.0)
    , vehicle_shiftposition(0)
    , vehicle_sys_status(0)
    , actuatormode(0)
    , shiftposition(0)
    , brakelight(0)
    , reverselight(0)
    , epb_status(0)
    , vehicle_auto_enable(false)
    , vehicle_lat_enable(false)
    , vehicle_lon_enable(false)
    , vehicle_epb_status(false)
    , road_vaild_flag(false)
    , calibration_flag(false)
    , write_enable_flag(false)
    , PowerFault(0)
    , ComFault(0)
    , USSFault(0)
    , ChassisFault(0)  {
  (void)_alloc;
    }



   typedef float _lat_targetangle_type;
  _lat_targetangle_type lat_targetangle;

   typedef float _lat_targettorque_type;
  _lat_targettorque_type lat_targettorque;

   typedef int16_t _vehicle_shiftposition_type;
  _vehicle_shiftposition_type vehicle_shiftposition;

   typedef int16_t _vehicle_sys_status_type;
  _vehicle_sys_status_type vehicle_sys_status;

   typedef int16_t _actuatormode_type;
  _actuatormode_type actuatormode;

   typedef int16_t _shiftposition_type;
  _shiftposition_type shiftposition;

   typedef int16_t _brakelight_type;
  _brakelight_type brakelight;

   typedef int16_t _reverselight_type;
  _reverselight_type reverselight;

   typedef int16_t _epb_status_type;
  _epb_status_type epb_status;

   typedef uint8_t _vehicle_auto_enable_type;
  _vehicle_auto_enable_type vehicle_auto_enable;

   typedef uint8_t _vehicle_lat_enable_type;
  _vehicle_lat_enable_type vehicle_lat_enable;

   typedef uint8_t _vehicle_lon_enable_type;
  _vehicle_lon_enable_type vehicle_lon_enable;

   typedef uint8_t _vehicle_epb_status_type;
  _vehicle_epb_status_type vehicle_epb_status;

   typedef uint8_t _road_vaild_flag_type;
  _road_vaild_flag_type road_vaild_flag;

   typedef uint8_t _calibration_flag_type;
  _calibration_flag_type calibration_flag;

   typedef uint8_t _write_enable_flag_type;
  _write_enable_flag_type write_enable_flag;

   typedef int16_t _PowerFault_type;
  _PowerFault_type PowerFault;

   typedef int16_t _ComFault_type;
  _ComFault_type ComFault;

   typedef int16_t _USSFault_type;
  _USSFault_type USSFault;

   typedef int16_t _ChassisFault_type;
  _ChassisFault_type ChassisFault;





  typedef boost::shared_ptr< ::control_msgs::control_sys_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::control_msgs::control_sys_<ContainerAllocator> const> ConstPtr;

}; // struct control_sys_

typedef ::control_msgs::control_sys_<std::allocator<void> > control_sys;

typedef boost::shared_ptr< ::control_msgs::control_sys > control_sysPtr;
typedef boost::shared_ptr< ::control_msgs::control_sys const> control_sysConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::control_msgs::control_sys_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::control_msgs::control_sys_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::control_msgs::control_sys_<ContainerAllocator1> & lhs, const ::control_msgs::control_sys_<ContainerAllocator2> & rhs)
{
  return lhs.lat_targetangle == rhs.lat_targetangle &&
    lhs.lat_targettorque == rhs.lat_targettorque &&
    lhs.vehicle_shiftposition == rhs.vehicle_shiftposition &&
    lhs.vehicle_sys_status == rhs.vehicle_sys_status &&
    lhs.actuatormode == rhs.actuatormode &&
    lhs.shiftposition == rhs.shiftposition &&
    lhs.brakelight == rhs.brakelight &&
    lhs.reverselight == rhs.reverselight &&
    lhs.epb_status == rhs.epb_status &&
    lhs.vehicle_auto_enable == rhs.vehicle_auto_enable &&
    lhs.vehicle_lat_enable == rhs.vehicle_lat_enable &&
    lhs.vehicle_lon_enable == rhs.vehicle_lon_enable &&
    lhs.vehicle_epb_status == rhs.vehicle_epb_status &&
    lhs.road_vaild_flag == rhs.road_vaild_flag &&
    lhs.calibration_flag == rhs.calibration_flag &&
    lhs.write_enable_flag == rhs.write_enable_flag &&
    lhs.PowerFault == rhs.PowerFault &&
    lhs.ComFault == rhs.ComFault &&
    lhs.USSFault == rhs.USSFault &&
    lhs.ChassisFault == rhs.ChassisFault;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::control_msgs::control_sys_<ContainerAllocator1> & lhs, const ::control_msgs::control_sys_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace control_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::control_msgs::control_sys_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::control_msgs::control_sys_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::control_msgs::control_sys_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::control_msgs::control_sys_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::control_msgs::control_sys_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::control_msgs::control_sys_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::control_msgs::control_sys_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d52a3c865eee57fb22d3fe059b3266b6";
  }

  static const char* value(const ::control_msgs::control_sys_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd52a3c865eee57fbULL;
  static const uint64_t static_value2 = 0x22d3fe059b3266b6ULL;
};

template<class ContainerAllocator>
struct DataType< ::control_msgs::control_sys_<ContainerAllocator> >
{
  static const char* value()
  {
    return "control_msgs/control_sys";
  }

  static const char* value(const ::control_msgs::control_sys_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::control_msgs::control_sys_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32   lat_targetangle\n"
"float32   lat_targettorque\n"
"int16     vehicle_shiftposition\n"
"int16     vehicle_sys_status\n"
"int16     actuatormode\n"
"int16     shiftposition\n"
"int16     brakelight\n"
"int16     reverselight\n"
"int16     epb_status\n"
"bool      vehicle_auto_enable\n"
"bool      vehicle_lat_enable\n"
"bool      vehicle_lon_enable\n"
"bool      vehicle_epb_status\n"
"bool      road_vaild_flag\n"
"bool      calibration_flag\n"
"bool      write_enable_flag\n"
"int16     PowerFault\n"
"int16     ComFault\n"
"int16     USSFault\n"
"int16     ChassisFault\n"
;
  }

  static const char* value(const ::control_msgs::control_sys_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::control_msgs::control_sys_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.lat_targetangle);
      stream.next(m.lat_targettorque);
      stream.next(m.vehicle_shiftposition);
      stream.next(m.vehicle_sys_status);
      stream.next(m.actuatormode);
      stream.next(m.shiftposition);
      stream.next(m.brakelight);
      stream.next(m.reverselight);
      stream.next(m.epb_status);
      stream.next(m.vehicle_auto_enable);
      stream.next(m.vehicle_lat_enable);
      stream.next(m.vehicle_lon_enable);
      stream.next(m.vehicle_epb_status);
      stream.next(m.road_vaild_flag);
      stream.next(m.calibration_flag);
      stream.next(m.write_enable_flag);
      stream.next(m.PowerFault);
      stream.next(m.ComFault);
      stream.next(m.USSFault);
      stream.next(m.ChassisFault);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct control_sys_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::control_msgs::control_sys_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::control_msgs::control_sys_<ContainerAllocator>& v)
  {
    s << indent << "lat_targetangle: ";
    Printer<float>::stream(s, indent + "  ", v.lat_targetangle);
    s << indent << "lat_targettorque: ";
    Printer<float>::stream(s, indent + "  ", v.lat_targettorque);
    s << indent << "vehicle_shiftposition: ";
    Printer<int16_t>::stream(s, indent + "  ", v.vehicle_shiftposition);
    s << indent << "vehicle_sys_status: ";
    Printer<int16_t>::stream(s, indent + "  ", v.vehicle_sys_status);
    s << indent << "actuatormode: ";
    Printer<int16_t>::stream(s, indent + "  ", v.actuatormode);
    s << indent << "shiftposition: ";
    Printer<int16_t>::stream(s, indent + "  ", v.shiftposition);
    s << indent << "brakelight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.brakelight);
    s << indent << "reverselight: ";
    Printer<int16_t>::stream(s, indent + "  ", v.reverselight);
    s << indent << "epb_status: ";
    Printer<int16_t>::stream(s, indent + "  ", v.epb_status);
    s << indent << "vehicle_auto_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_auto_enable);
    s << indent << "vehicle_lat_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_lat_enable);
    s << indent << "vehicle_lon_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_lon_enable);
    s << indent << "vehicle_epb_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_epb_status);
    s << indent << "road_vaild_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.road_vaild_flag);
    s << indent << "calibration_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.calibration_flag);
    s << indent << "write_enable_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.write_enable_flag);
    s << indent << "PowerFault: ";
    Printer<int16_t>::stream(s, indent + "  ", v.PowerFault);
    s << indent << "ComFault: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ComFault);
    s << indent << "USSFault: ";
    Printer<int16_t>::stream(s, indent + "  ", v.USSFault);
    s << indent << "ChassisFault: ";
    Printer<int16_t>::stream(s, indent + "  ", v.ChassisFault);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CONTROL_MSGS_MESSAGE_CONTROL_SYS_H
