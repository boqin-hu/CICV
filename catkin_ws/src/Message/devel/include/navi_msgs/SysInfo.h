// Generated by gencpp from file navi_msgs/SysInfo.msg
// DO NOT EDIT!


#ifndef NAVI_MSGS_MESSAGE_SYSINFO_H
#define NAVI_MSGS_MESSAGE_SYSINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace navi_msgs
{
template <class ContainerAllocator>
struct SysInfo_
{
  typedef SysInfo_<ContainerAllocator> Type;

  SysInfo_()
    : cpu_occupied(0.0)
    , mem_occupied(0.0)
    , cur_mileage(0.0)
    , history_mileage(0.0)  {
    }
  SysInfo_(const ContainerAllocator& _alloc)
    : cpu_occupied(0.0)
    , mem_occupied(0.0)
    , cur_mileage(0.0)
    , history_mileage(0.0)  {
  (void)_alloc;
    }



   typedef float _cpu_occupied_type;
  _cpu_occupied_type cpu_occupied;

   typedef float _mem_occupied_type;
  _mem_occupied_type mem_occupied;

   typedef double _cur_mileage_type;
  _cur_mileage_type cur_mileage;

   typedef double _history_mileage_type;
  _history_mileage_type history_mileage;





  typedef boost::shared_ptr< ::navi_msgs::SysInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::navi_msgs::SysInfo_<ContainerAllocator> const> ConstPtr;

}; // struct SysInfo_

typedef ::navi_msgs::SysInfo_<std::allocator<void> > SysInfo;

typedef boost::shared_ptr< ::navi_msgs::SysInfo > SysInfoPtr;
typedef boost::shared_ptr< ::navi_msgs::SysInfo const> SysInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::navi_msgs::SysInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::navi_msgs::SysInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::navi_msgs::SysInfo_<ContainerAllocator1> & lhs, const ::navi_msgs::SysInfo_<ContainerAllocator2> & rhs)
{
  return lhs.cpu_occupied == rhs.cpu_occupied &&
    lhs.mem_occupied == rhs.mem_occupied &&
    lhs.cur_mileage == rhs.cur_mileage &&
    lhs.history_mileage == rhs.history_mileage;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::navi_msgs::SysInfo_<ContainerAllocator1> & lhs, const ::navi_msgs::SysInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace navi_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::navi_msgs::SysInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::navi_msgs::SysInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::navi_msgs::SysInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::navi_msgs::SysInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::navi_msgs::SysInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::navi_msgs::SysInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::navi_msgs::SysInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "32c91a41efe8d7f00d4b592a7b9c6532";
  }

  static const char* value(const ::navi_msgs::SysInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x32c91a41efe8d7f0ULL;
  static const uint64_t static_value2 = 0x0d4b592a7b9c6532ULL;
};

template<class ContainerAllocator>
struct DataType< ::navi_msgs::SysInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "navi_msgs/SysInfo";
  }

  static const char* value(const ::navi_msgs::SysInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::navi_msgs::SysInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32  cpu_occupied\n"
"float32  mem_occupied\n"
"float64  cur_mileage\n"
"float64  history_mileage\n"
;
  }

  static const char* value(const ::navi_msgs::SysInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::navi_msgs::SysInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.cpu_occupied);
      stream.next(m.mem_occupied);
      stream.next(m.cur_mileage);
      stream.next(m.history_mileage);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SysInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::navi_msgs::SysInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::navi_msgs::SysInfo_<ContainerAllocator>& v)
  {
    s << indent << "cpu_occupied: ";
    Printer<float>::stream(s, indent + "  ", v.cpu_occupied);
    s << indent << "mem_occupied: ";
    Printer<float>::stream(s, indent + "  ", v.mem_occupied);
    s << indent << "cur_mileage: ";
    Printer<double>::stream(s, indent + "  ", v.cur_mileage);
    s << indent << "history_mileage: ";
    Printer<double>::stream(s, indent + "  ", v.history_mileage);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NAVI_MSGS_MESSAGE_SYSINFO_H
